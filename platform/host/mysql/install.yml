---
# ==============================================
# MySQL Installation on Host for Kubernetes Cluster
# ==============================================
# This playbook installs MySQL server on the host machine and configures
# it to be accessible from pods running in the Kubernetes cluster.
# It creates a Kubernetes Service with manual Endpoints pointing to the host IP.
#
# Uses a shared 'wapps_app' user for all services with service-specific databases.

- name: Install MySQL server and dependencies
  package:
    name: 
      - mysql-server
      - python3-pymysql
      - libmysqlclient-dev
    state: present

- name: Start and enable MySQL service
  systemd:
    name: mysql
    state: started
    enabled: yes

- name: Wait for MySQL to be ready
  wait_for:
    port: 3306
    host: 127.0.0.1
    timeout: 30

# ==============================================
# MySQL Root Configuration
# ==============================================
- name: Set MySQL root password
  mysql_user:
    name: root
    password: "{{ mysql_root_password | default('root_password') }}"
    login_unix_socket: /var/run/mysqld/mysqld.sock
    state: present
  ignore_errors: yes

# ==============================================
# MySQL Configuration for Cluster Access
# ==============================================
- name: Create MySQL configuration for cluster access
  copy:
    content: |
      [mysqld]
      # Bind to all interfaces so cluster pods can connect
      bind-address = 0.0.0.0
      port = 3306
      
      # Connection limits
      max_connections = 200
      
      # Performance tuning
      innodb_buffer_pool_size = 512M
      innodb_log_file_size = 128M
      
      # Security
      skip-name-resolve
      
      # Character set (required for Strapi and modern apps)
      character-set-server = utf8mb4
      collation-server = utf8mb4_unicode_ci
      
      # Logging (optional - uncomment for debugging)
      # general_log = 1
      # general_log_file = /var/log/mysql/general.log
      # log_error = /var/log/mysql/error.log
    dest: /etc/mysql/mysql.conf.d/wapps.cnf
    mode: '0644'
  register: mysql_config

- name: Restart MySQL if configuration changed
  systemd:
    name: mysql
    state: restarted
  when: mysql_config.changed

- name: Wait for MySQL after restart
  wait_for:
    port: 3306
    host: 127.0.0.1
    timeout: 30
  when: mysql_config.changed

# ==============================================
# Database Creation (all services)
# ==============================================
- name: Create databases for all services
  mysql_db:
    name: "{{ item }}"
    state: present
    login_user: root
    login_password: "{{ mysql_root_password | default('root_password') }}"
    login_unix_socket: /var/run/mysqld/mysqld.sock
    encoding: utf8mb4
    collation: utf8mb4_unicode_ci
  loop:
    # Editorial (Strapi CMS)
    - editorial_dev
    - editorial_staging
    - editorial_prod
    # Catalog BFF
    - catalog_dev
    - catalog_staging
    - catalog_prod
    # Discussion service
    - discussion_dev
    - discussion_staging
    - discussion_prod
    # Add more service databases here as needed
  when: mysql_provision_service_dbs | default(false)

# ==============================================
# Shared Database User Creation
# ==============================================
# Note: MySQL treats 'localhost' and '%' as different hosts
# Create user for '%' (remote access from cluster pods)
- name: Create shared wapps_app database user for remote access
  mysql_user:
    name: wapps_app
    password: "{{ mysql_wapps_password | default('wapps_password') }}"
    priv: 'editorial_dev.*:ALL/editorial_staging.*:ALL/editorial_prod.*:ALL/catalog_dev.*:ALL/catalog_staging.*:ALL/catalog_prod.*:ALL/discussion_dev.*:ALL/discussion_staging.*:ALL/discussion_prod.*:ALL'
    host: '%'
    state: present
    login_user: root
    login_password: "{{ mysql_root_password | default('root_password') }}"
    login_unix_socket: /var/run/mysqld/mysqld.sock
  when: mysql_provision_service_dbs | default(false)

# Create user for 'localhost' (local access from host machine)
- name: Create shared wapps_app database user for localhost
  mysql_user:
    name: wapps_app
    password: "{{ mysql_wapps_password | default('wapps_password') }}"
    priv: 'editorial_dev.*:ALL/editorial_staging.*:ALL/editorial_prod.*:ALL/catalog_dev.*:ALL/catalog_staging.*:ALL/catalog_prod.*:ALL/discussion_dev.*:ALL/discussion_staging.*:ALL/discussion_prod.*:ALL'
    host: 'localhost'
    state: present
    login_user: root
    login_password: "{{ mysql_root_password | default('root_password') }}"
    login_unix_socket: /var/run/mysqld/mysqld.sock
  when: mysql_provision_service_dbs | default(false)

# ==============================================
# Remote Admin User (for CI/CD DB provisioning)
# ==============================================
# Workflows connect over TCP (via mysql.mysql) and cannot use the root unix socket.
# Create a dedicated remote-capable admin user that can create per-service DBs/users.
- name: "Create MySQL admin user for remote provisioning (host: %)"
  mysql_user:
    name: "{{ mysql_admin_username | default('wapps_admin') }}"
    password: "{{ mysql_admin_password | default(mysql_root_password | default('root_password')) }}"
    priv: '*.*:ALL,GRANT'
    host: '%'
    state: present
    login_user: root
    login_password: "{{ mysql_root_password | default('root_password') }}"
    login_unix_socket: /var/run/mysqld/mysqld.sock

- name: "Create MySQL admin user for localhost provisioning (host: localhost)"
  mysql_user:
    name: "{{ mysql_admin_username | default('wapps_admin') }}"
    password: "{{ mysql_admin_password | default(mysql_root_password | default('root_password')) }}"
    priv: '*.*:ALL,GRANT'
    host: 'localhost'
    state: present
    login_user: root
    login_password: "{{ mysql_root_password | default('root_password') }}"
    login_unix_socket: /var/run/mysqld/mysqld.sock

# ==============================================
# Firewall Configuration
# ==============================================
- name: Allow MySQL through firewall
  ufw:
    rule: allow
    port: "3306"
    proto: tcp
    comment: "MySQL for Kubernetes cluster"

# ==============================================
# Kubernetes Service Integration
# ==============================================
- name: Get host primary IP address
  set_fact:
    host_ip: "{{ ansible_default_ipv4.address }}"

- name: Display detected host IP for verification
  debug:
    msg: "Detected host IP address: {{ host_ip }}"

- name: Create MySQL namespace in Kubernetes
  shell: kubectl create namespace mysql --dry-run=client -o yaml | kubectl apply -f -
  register: mysql_namespace

- name: Create Kubernetes Service for host MySQL
  shell: |
    cat <<EOF | kubectl apply -f -
    apiVersion: v1
    kind: Service
    metadata:
      name: mysql
      namespace: mysql
      labels:
        app: mysql
        type: external-host-service
      annotations:
        description: "MySQL running on host machine"
    spec:
      type: ClusterIP
      ports:
        - name: mysql
          port: 3306
          targetPort: 3306
          protocol: TCP
    EOF
  register: mysql_k8s_service

- name: Create Kubernetes Endpoints for host MySQL
  shell: |
    cat <<EOF | kubectl apply -f -
    apiVersion: v1
    kind: Endpoints
    metadata:
      name: mysql
      namespace: mysql
      labels:
        app: mysql
        type: external-host-service
      annotations:
        description: "Points to MySQL on host at {{ host_ip }}"
    subsets:
      - addresses:
          - ip: {{ host_ip }}
        ports:
          - name: mysql
            port: 3306
            protocol: TCP
    EOF
  register: mysql_k8s_endpoints

# ==============================================
# Shared MySQL Credentials Secret
# ==============================================
- name: Create shared MySQL credentials secret in mysql namespace
  shell: |
    kubectl create secret generic mysql-credentials \
      --namespace=mysql \
      --from-literal=DATABASE_CLIENT=mysql \
      --from-literal=DATABASE_HOST=mysql.mysql \
      --from-literal=DATABASE_PORT=3306 \
      --from-literal=DATABASE_USERNAME=wapps_app \
      --from-literal=DATABASE_PASSWORD={{ mysql_wapps_password | default('wapps_password') }} \
      --dry-run=client -o yaml | kubectl apply -f -
  register: mysql_shared_secret

# ==============================================
# Editorial Service Credentials
# ==============================================
- name: Create editorial namespace if not exists
  shell: kubectl create namespace editorial --dry-run=client -o yaml | kubectl apply -f -

- name: Determine editorial database name based on environment
  set_fact:
    editorial_db_name: "editorial_{% if target_env | default('staging') == 'development' %}dev{% elif target_env | default('staging') == 'production' %}prod{% else %}staging{% endif %}"

- name: Create editorial database credentials secret
  shell: |
    kubectl create secret generic editorial-db-credentials \
      --namespace=editorial \
      --from-literal=DATABASE_CLIENT=mysql \
      --from-literal=DATABASE_HOST=mysql.mysql \
      --from-literal=DATABASE_PORT=3306 \
      --from-literal=DATABASE_NAME={{ editorial_db_name }} \
      --from-literal=DATABASE_USERNAME=wapps_app \
      --from-literal=DATABASE_PASSWORD={{ mysql_wapps_password | default('wapps_password') }} \
      --dry-run=client -o yaml | kubectl apply -f -
  register: editorial_db_secret

# ==============================================
# Catalog Service Credentials
# ==============================================
- name: Create catalog namespace if not exists
  shell: kubectl create namespace catalog --dry-run=client -o yaml | kubectl apply -f -

- name: Determine catalog database name based on environment
  set_fact:
    catalog_db_name: "catalog_{% if target_env | default('staging') == 'development' %}dev{% elif target_env | default('staging') == 'production' %}prod{% else %}staging{% endif %}"

- name: Create catalog database credentials secret
  shell: |
    kubectl create secret generic catalog-db-credentials \
      --namespace=catalog \
      --from-literal=DATABASE_CLIENT=mysql \
      --from-literal=DATABASE_HOST=mysql.mysql \
      --from-literal=DATABASE_PORT=3306 \
      --from-literal=DATABASE_NAME={{ catalog_db_name }} \
      --from-literal=DATABASE_USERNAME=wapps_app \
      --from-literal=DATABASE_PASSWORD={{ mysql_wapps_password | default('wapps_password') }} \
      --dry-run=client -o yaml | kubectl apply -f -
  register: catalog_db_secret

# ==============================================
# Verification Tests
# ==============================================
- name: Test local MySQL connection
  shell: |
    mysql -u wapps_app -p{{ mysql_wapps_password | default('wapps_password') }} \
      -e "SELECT 1 AS test;" {{ editorial_db_name }}
  register: mysql_local_test
  changed_when: false
  failed_when: mysql_local_test.rc != 0

- name: Test MySQL connection from cluster
  shell: |
    kubectl run mysql-connection-test \
      --rm -i --restart=Never \
      --image=mysql:8.0 \
      --namespace=mysql \
      --command -- \
      mysql -h mysql.mysql -u wapps_app -p{{ mysql_wapps_password | default('wapps_password') }} \
      -e "SELECT 'Connection successful from cluster' AS status, NOW() AS timestamp, '{{ host_ip }}' AS host_ip;" {{ editorial_db_name }}
  register: mysql_cluster_test
  changed_when: false
  failed_when: false

- name: Get Kubernetes Service ClusterIP
  shell: kubectl get service mysql -n mysql -o jsonpath='{.spec.clusterIP}'
  register: mysql_service_ip
  changed_when: false

- name: Get Kubernetes Endpoints IP
  shell: kubectl get endpoints mysql -n mysql -o jsonpath='{.subsets[0].addresses[0].ip}'
  register: mysql_endpoint_ip
  changed_when: false

# ==============================================
# Display Installation Summary
# ==============================================
- name: Display MySQL installation summary
  debug:
    msg: |
      â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      â•‘          MySQL Installation Complete                           â•‘
      â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      
      ðŸ“Š DATABASE INFORMATION:
      â”œâ”€ Host IP: {{ host_ip }}
      â”œâ”€ Port: 3306
      â”œâ”€ Bind Address: 0.0.0.0 (accessible from cluster)
      â”œâ”€ Character Set: utf8mb4
      â””â”€ Max Connections: 200
      
      ðŸ“ DATABASES CREATED:
      â”œâ”€ editorial_dev, editorial_staging, editorial_prod
      â””â”€ catalog_dev, catalog_staging, catalog_prod
      
      ðŸ‘¤ SHARED DATABASE USER:
      â”œâ”€ Username: wapps_app
      â”œâ”€ Password: {{ mysql_wapps_password | default('wapps_password') }}
      â”œâ”€ Permissions: ALL on editorial_*.*, catalog_*.*
      â””â”€ Access: From any host (%)
      
      â˜¸ï¸  KUBERNETES INTEGRATION:
      â”œâ”€ Namespace: mysql
      â”œâ”€ Service Name: mysql
      â”œâ”€ Service ClusterIP: {{ mysql_service_ip.stdout }}
      â”œâ”€ Endpoint IP: {{ mysql_endpoint_ip.stdout }} (host)
      â””â”€ DNS: mysql.mysql.svc.cluster.local
      
      ðŸ” KUBERNETES SECRETS CREATED:
      â”œâ”€ mysql-credentials (namespace: mysql) - shared credentials
      â”œâ”€ editorial-db-credentials (namespace: editorial)
      â””â”€ catalog-db-credentials (namespace: catalog)
      
      âœ… CONNECTION TESTS:
      â”œâ”€ Local: {{ 'PASSED âœ“' if mysql_local_test.rc == 0 else 'FAILED âœ—' }}
      â””â”€ From Cluster: {{ 'PASSED âœ“' if mysql_cluster_test.rc == 0 else 'CHECK LOGS' }}
      
      ðŸ“ USAGE IN PODS:
      
      Option 1 - Use service-specific secret (recommended):
        envFrom:
          - secretRef:
              name: editorial-db-credentials  # or catalog-db-credentials
      
      Option 2 - Use shared secret + set DATABASE_NAME:
        envFrom:
          - secretRef:
              name: mysql-credentials
        env:
          - name: DATABASE_NAME
            value: "editorial_dev"
      
      ðŸ”§ MAINTENANCE COMMANDS:
      
      View secrets:
        kubectl get secret mysql-credentials -n mysql -o yaml
        kubectl get secret editorial-db-credentials -n editorial -o yaml
      
      Test connection from cluster:
        kubectl run mysql-test --rm -it --restart=Never \
          --image=mysql:8.0 --namespace=mysql -- \
          mysql -h mysql.mysql -u wapps_app -p{{ mysql_wapps_password | default('wapps_password') }} \
          -e "SHOW DATABASES;"
      
      Access MySQL from host:
        mysql -u wapps_app -p{{ mysql_wapps_password | default('wapps_password') }} {{ editorial_db_name }}
      
      â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
      â•‘  MySQL is accessible from pods via: mysql.mysql:3306           â•‘
      â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
