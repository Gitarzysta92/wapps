# Nginx reverse proxy configuration for {{ target_env }} environment
# Generated by Ansible - do not edit manually

# K3s API - Kubernetes API Server
server {
    listen 80;
    server_name k3s-api.{{ target_env }}.wapps.com;
    
    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name k3s-api.{{ target_env }}.wapps.com;
    
    # SSL configuration
    ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
    ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    
    # Proxy to K3s API
    location / {
        proxy_pass https://127.0.0.1:6443;
        proxy_ssl_verify off;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}

# Node Exporter - Metrics
server {
    listen 80;
    server_name metrics.{{ target_env }}.wapps.com;
    
    # Proxy to Node Exporter
    location / {
        proxy_pass http://127.0.0.1:9100;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}

# API Gateway - All API traffic goes through ingress-nginx
server {
    listen 80;
    server_name *.api.{{ target_env }}.wapps.com;
    
    # Route HTTP API traffic through ingress-nginx
    # This enables firebase-auth-validator integration via ingress annotations
    location / {
        proxy_pass http://127.0.0.1:32080;  # Ingress-nginx NodePort (HTTP)
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;
        
        # Preserve Authorization header (important for JWT)
        proxy_pass_request_headers on;
        
        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts (adjust for your API needs)
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Buffering
        proxy_buffering off;
        proxy_request_buffering off;
        
        # Logging
        access_log /var/log/nginx/api-gateway.access.log;
        error_log /var/log/nginx/api-gateway.error.log;
    }
}

server {
    listen 443 ssl http2;
    server_name *.api.{{ target_env }}.wapps.com;
    
    # SSL configuration
    ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
    ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    
    # Route HTTPS API traffic through ingress-nginx
    # Host nginx terminates SSL, then proxies as HTTP to ingress-nginx
    location / {
        proxy_pass http://127.0.0.1:32080;  # Ingress-nginx NodePort (HTTP)
        
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;
        
        # Preserve Authorization header (important for JWT)
        proxy_pass_request_headers on;
        
        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts (adjust for your API needs)
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Buffering
        proxy_buffering off;
        proxy_request_buffering off;
        
        # Logging
        access_log /var/log/nginx/api-gateway.access.log;
        error_log /var/log/nginx/api-gateway.error.log;
    }
}

# ArgoCD - Requires SSL passthrough for ingress-nginx
server {
    listen 80;
    server_name argocd.{{ target_env }}.wapps.com;
    
    # Redirect HTTP to HTTPS
    return 301 https://$server_name$request_uri;
}

server {
    listen 443 ssl http2;
    server_name argocd.{{ target_env }}.wapps.com;
    
    # SSL configuration
    ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
    ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    
    # Proxy to ingress-nginx HTTPS NodePort for SSL passthrough
    # Note: Host nginx terminates SSL, then proxies to ingress-nginx
    # Ingress-nginx will handle SSL passthrough to ArgoCD based on ingress annotations
    location / {
        proxy_pass https://127.0.0.1:32443;  # Ingress-nginx NodePort (HTTPS)
        proxy_ssl_verify off;
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;
        
        # WebSocket support
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
    }
}

# Default server - route all other traffic to Kubernetes cluster
server {
    listen 80 default_server;
    server_name _;
    
    # Route HTTP traffic to Kubernetes cluster via ingress
    location / {
        # Try to find the service in the cluster
        # This will be handled by the ingress controller
        proxy_pass http://127.0.0.1:32080;  # Ingress-nginx NodePort (HTTP)
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;
        
        # WebSocket support for ingress
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Error handling - if service not found in cluster
        proxy_intercept_errors on;
        error_page 502 503 504 = @cluster_error;
    }
    
    # Error page for services not found in cluster
    location @cluster_error {
        return 200 '<!DOCTYPE html><html><head><title>Service Not Found - {{ target_env | title }} Environment</title><style>body{font-family:Arial,sans-serif;margin:40px;background:#f5f5f5}.container{max-width:800px;margin:0 auto;background:white;padding:30px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,0.1)}h1{color:#333;border-bottom:2px solid #dc3545;padding-bottom:10px}.service{margin:20px 0;padding:15px;background:#f8f9fa;border-left:4px solid #007acc;border-radius:4px}.service h3{margin:0 0 10px 0;color:#007acc}.service p{margin:5px 0;color:#666}.url{font-family:monospace;background:#e9ecef;padding:2px 6px;border-radius:3px}.status{display:inline-block;padding:2px 8px;border-radius:12px;font-size:12px;font-weight:bold}.status.available{background:#d4edda;color:#155724}.status.not-found{background:#f8d7da;color:#721c24}</style></head><body><div class="container"><h1>Service Not Found - {{ target_env | title }} Environment</h1><p>The service <strong><span class="url">$host</span></strong> was not found in the Kubernetes cluster.</p><div class="service"><h3>üîç Available Host-Level Services</h3><p><strong>ArgoCD:</strong> <span class="url">https://argocd.{{ target_env }}.wapps.com</span> <span class="status available">Available</span></p><p><strong>K3s API:</strong> <span class="url">https://k3s-api.{{ target_env }}.wapps.com</span> <span class="status available">Available</span></p><p><strong>Node Exporter:</strong> <span class="url">http://metrics.{{ target_env }}.wapps.com</span> <span class="status available">Available</span></p></div><div class="service"><h3>‚ò∏Ô∏è Cluster Services</h3><p>Other services should be deployed to the Kubernetes cluster and will be handled by the ingress controller.</p><p><strong>Status:</strong> <span class="status not-found">Service not found in cluster</span></p></div><div style="margin-top:30px;padding:15px;background:#fff3cd;border-radius:4px;border-left:4px solid #ffc107"><p><strong>üí° Tip:</strong> Deploy your service to the Kubernetes cluster with an ingress resource to make it accessible.</p><p><strong>üîß Check:</strong> Verify the service is running with <code>kubectl get services</code> and has an ingress configured.</p></div></div></body></html>';
        add_header Content-Type text/html;
    }
}

server {
    listen 443 ssl http2 default_server;
    server_name _;
    
    # SSL configuration for default server
    ssl_certificate /etc/ssl/certs/nginx-selfsigned.crt;
    ssl_certificate_key /etc/ssl/private/nginx-selfsigned.key;
    ssl_protocols TLSv1.2 TLSv1.3;
    ssl_ciphers ECDHE-RSA-AES256-GCM-SHA512:DHE-RSA-AES256-GCM-SHA512:ECDHE-RSA-AES256-GCM-SHA384:DHE-RSA-AES256-GCM-SHA384;
    ssl_prefer_server_ciphers off;
    
    # Route HTTPS traffic to Kubernetes cluster via ingress
    # Host nginx terminates SSL, then proxies as HTTP to ingress-nginx
    # Note: For services requiring SSL passthrough (like ArgoCD), 
    # they should have their own server block proxying to 32443
    location / {
        # Try to find the service in the cluster
        # This will be handled by the ingress controller
        proxy_pass http://127.0.0.1:32080;  # Ingress-nginx NodePort (HTTP)
        proxy_set_header Host $host;
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header X-Forwarded-Host $host;
        proxy_set_header X-Forwarded-Port $server_port;
        
        # WebSocket support for ingress
        proxy_http_version 1.1;
        proxy_set_header Upgrade $http_upgrade;
        proxy_set_header Connection "upgrade";
        
        # Timeouts
        proxy_connect_timeout 60s;
        proxy_send_timeout 60s;
        proxy_read_timeout 60s;
        
        # Error handling - if service not found in cluster
        proxy_intercept_errors on;
        error_page 502 503 504 = @cluster_error;
    }
    
    # Error page for services not found in cluster
    location @cluster_error {
        return 200 '<!DOCTYPE html><html><head><title>Service Not Found - {{ target_env | title }} Environment</title><style>body{font-family:Arial,sans-serif;margin:40px;background:#f5f5f5}.container{max-width:800px;margin:0 auto;background:white;padding:30px;border-radius:8px;box-shadow:0 2px 10px rgba(0,0,0,0.1)}h1{color:#333;border-bottom:2px solid #dc3545;padding-bottom:10px}.service{margin:20px 0;padding:15px;background:#f8f9fa;border-left:4px solid #007acc;border-radius:4px}.service h3{margin:0 0 10px 0;color:#007acc}.service p{margin:5px 0;color:#666}.url{font-family:monospace;background:#e9ecef;padding:2px 6px;border-radius:3px}.status{display:inline-block;padding:2px 8px;border-radius:12px;font-size:12px;font-weight:bold}.status.available{background:#d4edda;color:#155724}.status.not-found{background:#f8d7da;color:#721c24}</style></head><body><div class="container"><h1>Service Not Found - {{ target_env | title }} Environment</h1><p>The service <strong><span class="url">$host</span></strong> was not found in the Kubernetes cluster.</p><div class="service"><h3>üîç Available Host-Level Services</h3><p><strong>ArgoCD:</strong> <span class="url">https://argocd.{{ target_env }}.wapps.com</span> <span class="status available">Available</span></p><p><strong>K3s API:</strong> <span class="url">https://k3s-api.{{ target_env }}.wapps.com</span> <span class="status available">Available</span></p><p><strong>Node Exporter:</strong> <span class="url">http://metrics.{{ target_env }}.wapps.com</span> <span class="status available">Available</span></p></div><div class="service"><h3>‚ò∏Ô∏è Cluster Services</h3><p>Other services should be deployed to the Kubernetes cluster and will be handled by the ingress controller.</p><p><strong>Status:</strong> <span class="status not-found">Service not found in cluster</span></p></div><div style="margin-top:30px;padding:15px;background:#fff3cd;border-radius:4px;border-left:4px solid #ffc107"><p><strong>üí° Tip:</strong> Deploy your service to the Kubernetes cluster with an ingress resource to make it accessible.</p><p><strong>üîß Check:</strong> Verify the service is running with <code>kubectl get services</code> and has an ingress configured.</p></div></div></body></html>';
        add_header Content-Type text/html;
    }
}
