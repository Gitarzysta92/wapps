---
- name: Host Environment Provisioning - Main Playbook
  hosts: localhost
  become: yes
  vars:
    apps_dir: "/opt/wapps"
    ansible_user: "{{ ansible_env.USER | default('root') }}"

  tasks:
    - name: Display provisioning start
      debug:
        msg: |
          Starting host environment provisioning...
          Environment: {{ target_env | default('staging') }}
          Git SHA: {{ git_sha | default('main') }}
          Target directory: {{ apps_dir }}

    - name: Include system configuration
      include_tasks: system/configure.yml
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Include MySQL installation
      include_tasks: mysql/install.yml
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Include K3s installation
      include_tasks: k3s/install.yml
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Create ArgoCD namespace
      shell: kubectl apply -f {{ playbook_dir }}/../cluster/argocd/namespace.yaml
      register: argocd_namespace
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Install ArgoCD in cluster
      shell: |
        kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml
      register: argocd_install
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Wait for ArgoCD secrets to be created
      shell: |
        for i in {1..30}; do
          if kubectl get secret argocd-secret -n argocd 2>/dev/null && \
             kubectl get secret argocd-redis -n argocd 2>/dev/null; then
            echo "ArgoCD secrets are ready"
            exit 0
          fi
          echo "Waiting for ArgoCD secrets... ($i/30)"
          sleep 2
        done
        echo "Warning: Some ArgoCD secrets may not be ready yet"
        exit 0
      register: argocd_secrets_wait
      changed_when: false
      failed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Display ArgoCD pod status for debugging
      shell: kubectl get pods -n argocd -o wide
      register: argocd_pods_status
      changed_when: false
      failed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Check if ArgoCD service needs patching
      shell: kubectl -n argocd get svc argocd-server -o jsonpath='{.spec.type}'
      register: argocd_svc_type
      changed_when: false
      failed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Remove ArgoCD NodePorts (use ClusterIP + Ingress)
      shell: |
        kubectl -n argocd patch svc argocd-server --type='merge' -p '{"spec":{"type":"ClusterIP"}}'
      register: argocd_patch
      when: 
        - target_env | default('staging') in ['development', 'staging', 'production']
        - argocd_svc_type.stdout != 'ClusterIP'
        - argocd_svc_type.rc == 0

    - name: Wait for ArgoCD to be ready
      shell: kubectl wait --for=condition=available --timeout=300s deployment/argocd-server -n argocd
      register: argocd_wait
      changed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Apply ArgoCD configuration via kustomization
      shell: |
        # Apply ConfigMaps for argocd-cm (admin account capabilities) and argocd-rbac-cm (RBAC policy)
        # This is cleaner than patching ConfigMaps after installation
        kubectl apply -k {{ playbook_dir }}/../cluster/argocd
      register: argocd_config
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Restart ArgoCD server to apply configuration changes
      shell: kubectl rollout restart deployment/argocd-server -n argocd
      register: argocd_restart
      when: 
        - target_env | default('staging') in ['development', 'staging', 'production']
        - argocd_config is changed

    - name: Wait for ArgoCD server restart
      shell: kubectl wait --for=condition=available --timeout=180s deployment/argocd-server -n argocd
      register: argocd_restart_wait
      changed_when: false
      when: 
        - target_env | default('staging') in ['development', 'staging', 'production']
        - argocd_restart is changed

    - name: Check if ArgoCD repository secret exists
      shell: kubectl get secret wapps-repo-secret -n argocd 2>/dev/null || echo "NOT_FOUND"
      register: argocd_repo_secret_check
      changed_when: false
      failed_when: false
      when: 
        - target_env | default('staging') in ['development', 'staging', 'production']
        - git_token | default('') != ''

    - name: Create ArgoCD repository credentials secret
      shell: |
        kubectl create secret generic wapps-repo-secret \
          --from-literal=type=git \
          --from-literal=url=https://github.com/Gitarzysta92/wapps.git \
          --from-literal=username=Gitarzysta92 \
          --from-literal=password={{ git_token }} \
          --namespace=argocd \
          --dry-run=client -o yaml | kubectl apply -f -
        kubectl label secret wapps-repo-secret -n argocd argocd.argoproj.io/secret-type=repository --overwrite
      register: argocd_repo_secret
      when:
        - target_env | default('staging') in ['development', 'staging', 'production']
        - git_token | default('') != ''
        - argocd_repo_secret_check.stdout == "NOT_FOUND" or argocd_repo_secret_check.rc != 0

    - name: Verify ArgoCD repository secret
      shell: kubectl get secret wapps-repo-secret -n argocd -o jsonpath='{.metadata.labels.argocd\.argoproj\.io/secret-type}'
      register: argocd_repo_secret_verify
      changed_when: false
      failed_when: argocd_repo_secret_verify.stdout != 'repository'
      when:
        - target_env | default('staging') in ['development', 'staging', 'production']
        - git_token | default('') != ''

    - name: Map environment name to directory
      set_fact:
        env_dir: "{% if target_env | default('staging') == 'development' %}dev{% elif target_env | default('staging') == 'production' %}prod{% elif target_env | default('staging') == 'staging' %}dev{% else %}dev{% endif %}"
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Set ArgoCD overlay path
      set_fact:
        argocd_overlay_path: "{{ (playbook_dir | dirname | dirname) }}/environments/{{ env_dir }}/platform/argocd-kustomization"
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Apply ArgoCD ingress using Kustomize overlay
      shell: kubectl apply -k .
      args:
        chdir: "{{ argocd_overlay_path }}"
      register: argocd_ingress
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Apply ArgoCD AppProject (wapps-platform)
      shell: kubectl apply -f {{ (playbook_dir | dirname | dirname) }}/argocd/projects/platform-project.yaml
      register: argocd_project
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Apply ArgoCD App of Apps
      shell: kubectl apply -f {{ (playbook_dir | dirname | dirname) }}/argocd/app-of-apps.yaml
      register: app_of_apps
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Wait for App of Apps application to be created
      shell: |
        for i in {1..30}; do
          if kubectl get application wapps-app-of-apps -n argocd 2>/dev/null; then
            echo "App of Apps is ready"
            exit 0
          fi
          echo "Waiting for App of Apps... ($i/30)"
          sleep 2
        done
        echo "Warning: App of Apps may not be ready yet"
        exit 0
      register: app_of_apps_wait
      changed_when: false
      failed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Display App of Apps status
      shell: kubectl get application -n argocd
      register: argocd_apps_status
      changed_when: false
      failed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Create RabbitMQ namespace
      shell: kubectl create namespace rabbitmq --dry-run=client -o yaml | kubectl apply -f -
      register: rabbitmq_namespace
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Create/Update RabbitMQ secrets
      shell: |
        RABBITMQ_USERNAME="{{ lookup('env', 'RABBITMQ_USERNAME') | default('admin', true) }}"
        RABBITMQ_PASSWORD="{{ lookup('env', 'RABBITMQ_PASSWORD') | default('changeme', true) }}"
        
        # Create/update secret (Helm will reference this for RabbitMQ password)
        kubectl create secret generic rabbitmq-credentials \
          --from-literal=host="rabbitmq.rabbitmq" \
          --from-literal=port="5672" \
          --from-literal=username="${RABBITMQ_USERNAME}" \
          --from-literal=password="${RABBITMQ_PASSWORD}" \
          --from-literal=rabbitmq-password="${RABBITMQ_PASSWORD}" \
          --from-literal=management-port="15672" \
          --from-literal=connection-string="amqp://${RABBITMQ_USERNAME}:${RABBITMQ_PASSWORD}@rabbitmq.rabbitmq:5672/" \
          --namespace=rabbitmq \
          --dry-run=client -o yaml | kubectl apply -f -
      register: rabbitmq_secrets
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Deploy RabbitMQ ArgoCD Application (Helm)
      shell: kubectl apply -f {{ (playbook_dir | dirname | dirname) }}/argocd/applications/platform/rabbitmq.yaml
      register: rabbitmq_app
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Deploy RabbitMQ Config ArgoCD Application (Ingress)
      shell: kubectl apply -f {{ (playbook_dir | dirname | dirname) }}/argocd/applications/platform/rabbitmq-config.yaml
      register: rabbitmq_config_app
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Wait for RabbitMQ applications to be created
      shell: |
        for i in {1..30}; do
          if kubectl get application rabbitmq -n argocd 2>/dev/null && \
             kubectl get application rabbitmq-config -n argocd 2>/dev/null; then
            echo "RabbitMQ applications are ready"
            exit 0
          fi
          echo "Waiting for RabbitMQ applications... ($i/30)"
          sleep 2
        done
        echo "Warning: RabbitMQ applications may not be ready yet"
        exit 0
      register: rabbitmq_app_wait
      changed_when: false
      failed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Display RabbitMQ status
      shell: |
        echo "=== RabbitMQ Helm Chart ==="
        kubectl get application rabbitmq -n argocd -o wide 2>/dev/null || echo "RabbitMQ application not found"
        echo ""
        echo "=== RabbitMQ Configuration ==="
        kubectl get application rabbitmq-config -n argocd -o wide 2>/dev/null || echo "RabbitMQ config application not found"
      register: rabbitmq_status
      changed_when: false
      failed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Create MinIO namespace
      shell: kubectl create namespace minio --dry-run=client -o yaml | kubectl apply -f -
      register: minio_namespace
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Check if MinIO secrets exist
      shell: kubectl get secret minio-credentials -n minio 2>/dev/null || echo "NOT_FOUND"
      register: minio_secret_check
      changed_when: false
      failed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Create MinIO secrets
      shell: |
        MINIO_ROOT_USER="{{ lookup('env', 'MINIO_ROOT_USER') | default('admin', true) }}"
        MINIO_ROOT_PASSWORD="{{ lookup('env', 'MINIO_ROOT_PASSWORD') | default('changeme', true) }}"
        
        kubectl create secret generic minio-credentials \
          --from-literal=endpoint="minio.minio:9000" \
          --from-literal=rootUser="${MINIO_ROOT_USER}" \
          --from-literal=rootPassword="${MINIO_ROOT_PASSWORD}" \
          --from-literal=accessKey="${MINIO_ROOT_USER}" \
          --from-literal=secretKey="${MINIO_ROOT_PASSWORD}" \
          --from-literal=useSSL="false" \
          --from-literal=region="us-east-1" \
          --namespace=minio \
          --dry-run=client -o yaml | kubectl apply -f -
      register: minio_secrets
      when:
        - target_env | default('staging') in ['development', 'staging', 'production']
        - minio_secret_check.stdout == "NOT_FOUND" or minio_secret_check.rc != 0

    - name: Deploy MinIO ArgoCD Application (Helm)
      shell: kubectl apply -f {{ (playbook_dir | dirname | dirname) }}/argocd/applications/platform/minio.yaml
      register: minio_app
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Deploy MinIO Config ArgoCD Application (Ingress)
      shell: kubectl apply -f {{ (playbook_dir | dirname | dirname) }}/argocd/applications/platform/minio-config.yaml
      register: minio_config_app
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Wait for MinIO applications to be created
      shell: |
        for i in {1..30}; do
          if kubectl get application minio -n argocd 2>/dev/null && \
             kubectl get application minio-config -n argocd 2>/dev/null; then
            echo "MinIO applications are ready"
            exit 0
          fi
          echo "Waiting for MinIO applications... ($i/30)"
          sleep 2
        done
        echo "Warning: MinIO applications may not be ready yet"
        exit 0
      register: minio_app_wait
      changed_when: false
      failed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Display MinIO status
      shell: |
        echo "=== MinIO Helm Chart ==="
        kubectl get application minio -n argocd -o wide 2>/dev/null || echo "MinIO application not found"
        echo ""
        echo "=== MinIO Configuration ==="
        kubectl get application minio-config -n argocd -o wide 2>/dev/null || echo "MinIO config application not found"
      register: minio_status
      changed_when: false
      failed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Create OpenSearch namespace
      shell: kubectl create namespace opensearch --dry-run=client -o yaml | kubectl apply -f -
      register: opensearch_namespace
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Check if OpenSearch secrets exist
      shell: kubectl get secret opensearch-credentials -n opensearch 2>/dev/null || echo "NOT_FOUND"
      register: opensearch_secret_check
      changed_when: false
      failed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Create OpenSearch secrets
      shell: |
        OPENSEARCH_USERNAME="{{ lookup('env', 'OPENSEARCH_USERNAME') | default('admin', true) }}"
        OPENSEARCH_PASSWORD="{{ lookup('env', 'OPENSEARCH_PASSWORD') | default('changeme', true) }}"
        
        kubectl create secret generic opensearch-credentials \
          --from-literal=username="${OPENSEARCH_USERNAME}" \
          --from-literal=password="${OPENSEARCH_PASSWORD}" \
          --namespace=opensearch \
          --dry-run=client -o yaml | kubectl apply -f -
      register: opensearch_secrets
      when:
        - target_env | default('staging') in ['development', 'staging', 'production']
        - opensearch_secret_check.stdout == "NOT_FOUND" or opensearch_secret_check.rc != 0

    - name: Deploy OpenSearch ArgoCD Application (Helm)
      shell: kubectl apply -f {{ (playbook_dir | dirname | dirname) }}/argocd/applications/platform/opensearch.yaml
      register: opensearch_app
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Deploy OpenSearch Config ArgoCD Application (Ingress)
      shell: kubectl apply -f {{ (playbook_dir | dirname | dirname) }}/argocd/applications/platform/opensearch-config.yaml
      register: opensearch_config_app
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Display OpenSearch status
      shell: |
        echo "=== OpenSearch Helm Chart ==="
        kubectl get application opensearch -n argocd -o wide 2>/dev/null || echo "OpenSearch application not found"
        echo ""
        echo "=== OpenSearch Configuration ==="
        kubectl get application opensearch-config -n argocd -o wide 2>/dev/null || echo "OpenSearch config application not found"
      register: opensearch_status
      changed_when: false
      failed_when: false
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Include Node Exporter installation
      include_tasks: node-exporter/install.yml
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Include Tailscale installation
      include_tasks: tailscale/install.yml
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Include Ingress installation
      include_tasks: ingress/install.yml
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Include Nginx reverse proxy installation
      include_tasks: nginx/install.yml
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Create aggregator namespace for applications
      shell: kubectl create namespace aggregator --dry-run=client -o yaml | kubectl apply -f -
      register: aggregator_namespace
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Check if GHCR secret exists in aggregator namespace
      shell: kubectl get secret ghcr-secret -n aggregator 2>/dev/null || echo "NOT_FOUND"
      register: ghcr_secret_check
      changed_when: false
      failed_when: false
      when: 
        - target_env | default('staging') in ['development', 'staging', 'production']
        - git_token | default('') != ''

    - name: Create GHCR image pull secret in aggregator namespace
      shell: |
        kubectl create secret docker-registry ghcr-secret \
          --docker-server=ghcr.io \
          --docker-username={{ github_username | default('Gitarzysta92') }} \
          --docker-password={{ git_token }} \
          --namespace=aggregator \
          --dry-run=client -o yaml | kubectl apply -f -
      register: ghcr_secret_aggregator
      when:
        - target_env | default('staging') in ['development', 'staging', 'production']
        - git_token | default('') != ''
        - ghcr_secret_check.stdout == "NOT_FOUND" or ghcr_secret_check.rc != 0

    - name: Create editorial namespace for backend services
      shell: kubectl create namespace editorial --dry-run=client -o yaml | kubectl apply -f -
      register: editorial_namespace
      when: target_env | default('staging') in ['development', 'staging', 'production']

    - name: Check if GHCR secret exists in editorial namespace
      shell: kubectl get secret ghcr-secret -n editorial 2>/dev/null || echo "NOT_FOUND"
      register: ghcr_secret_editorial_check
      changed_when: false
      failed_when: false
      when: 
        - target_env | default('staging') in ['development', 'staging', 'production']
        - git_token | default('') != ''

    - name: Create GHCR image pull secret in editorial namespace
      shell: |
        kubectl create secret docker-registry ghcr-secret \
          --docker-server=ghcr.io \
          --docker-username={{ github_username | default('gitarzysta92') }} \
          --docker-password={{ git_token }} \
          --namespace=editorial \
          --dry-run=client -o yaml | kubectl apply -f -
      register: ghcr_secret_editorial
      when:
        - target_env | default('staging') in ['development', 'staging', 'production']
        - git_token | default('') != ''
        - ghcr_secret_editorial_check.stdout == "NOT_FOUND" or ghcr_secret_editorial_check.rc != 0

    - name: Include DNS installation
      include_tasks: dns/install.yml
      vars:
        target_ip: "{{ tailscale_ip.stdout | default(ansible_default_ipv4.address) }}"
      when: target_env | default('staging') in ['development', 'staging', 'production']



    - name: Display provisioning summary
      debug:
        msg: |
          Host provisioning completed successfully!
          Environment: {{ target_env | default('staging') }}
          Git SHA: {{ git_sha | default('main') }}
          Applications directory: {{ apps_dir }}
          Installed services:
            - ArgoCD (Cluster) - GitOps CD
            - ArgoCD Repository Credentials - Git access for private repos
            - ArgoCD AppProject (wapps-platform) - Project configuration
            - ArgoCD App of Apps - Application Management
            - RabbitMQ (Platform) - Message Broker (Helm + Config)
            - MinIO (Platform) - Object Storage (Helm + Config)
            - OpenSearch (Platform) - Search Engine (Helm + Config)
            - GitHub Actions Runner - CI/CD
            - K3s (port 6443) - Kubernetes
            - Node Exporter (port 9100) - Metrics
            - Tailscale (port 41641) - VPN networking
            - Nginx (ports 80/443) - Reverse Proxy
            - NTP - Time synchronization
            - GHCR Image Pull Secrets (aggregator, editorial namespaces)
          
          ArgoCD Applications Created:
            - rabbitmq: Helm chart deployment
            - rabbitmq-config: Ingress configuration overlay
            - minio: Helm chart deployment
            - minio-config: Ingress configuration overlay
            - opensearch: Helm chart deployment
            - opensearch-config: Ingress configuration overlay
          Logs directory: {{ apps_dir }}/logs